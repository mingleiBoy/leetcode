# 94. 二叉树的中序遍历

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


# 函数作用：按中序遍历，打印整棵树的所有节点
def dfs(self, root: TreeNode):
    # 终止条件
    if not root:
        return

    # 递归就是将一个大问题化为一个个的小问题去解决（分治）
    # 而且是调用同一个方法 f(n) 去解决

    # !!! 这句话很重要：执行完递归函数之后，表示这个问题下的所有子问题都已经解决完毕 (结论1)!!!
    # !!! 永远不要去人脑单步调试代码，人脑才能记住几层栈 !!!

    self.dfs(root.left)     # 执行递归

    '''
    具体说：self.dfs(root.left) 这一步表示执行完之后，以 root.left 为根节点的树中所有节点打印完毕

    为什么可以达到这个效果，也就是结论1为什么是对的？ 栈的特点
    遇到有子问题没有解决的，就会将当前的变量环境入栈，暂时搁置
    调用函数去解决子问题，直到子问题可以解决
    子问题解决后，回到上层调用的变量环境
    对于上层的代码来说，走完了递归的函数，就是解决完了子问题
    '''

    '''
    当前问题的子问题是如何解决的？
    再回到函数作用（明确函数作用是递归的核心）：按中序遍历，打印整棵树的所有节点
    具体的执行过程：
      1. 空节点：直接返回。
      2. 非空节点：先打印某个节点的左子树（子问题），再打印当前节点，再打印所有右子树（子问题）
    很重要的条件：对于每个子问题，不论是不是最小子问题，这个执行过程从逻辑上讲能解决问题。
    只要可以保证上面解法的正确，就能保证对于任何层级的递归函数，执行完后所有子问题都是解决的。
    '''

    '''
    也可以从斐波那切数列的角度理解
    f(n) = f(n-1) + f(n-2)
         = f(n-2) + f(n-3) + f(n-3) + f(n-4)
         ...
         = mf(0) + nf(1)
    m,n 是确定的值，若已知 f(0) 和 f(1)，就可以得到 f(n)

    中序遍历的dfs()函数就是这个 f(n)
    dfs(root.left) 和 dfs(root.right) 可以类比 f(n-1) 和 f(n-2)
    dfs()的 return 就相当于 f(0) 和 f(1) 这种初始值的解
    '''

    '''
    @里达：
    
    递归适用的场景：
    1. 有限的空间，大问题转换为小问题的集合
    2. 趋势走向是确定的、或者说是单调的
    3. 一定是有尽头的
    4. 每走一步路线是确定的，递归下去一定是走了所有的路线，只能重复，不会漏掉
    理解：
    递归也就是 root = return { .. return { .. return }}}，可以理解为block套block
    中序遍历等例子：递归的妙处：子任务处理完之前，上层的代码是暂停的，只有同层的代码都执行完，再上一层才能继续。微妙的联想：autoreleasepool
    '''

    print(root.val)
    self.dfs(root.right)
    return

